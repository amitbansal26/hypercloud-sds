# HyperCloud Storage CRD 디자인 문서

# 용어 설명
## Custom Resource (CR)
CR은 k8s에 사용자가 원하는 형태의 객체를 만들고, k8s의 API 서버를 통해 접근 가능하게 합니다. CR은 k8s가 알고 있는 객체이기 때문에 사용자가 정의한 객체를 `kubectl`로 조작하거나 Kubernetes UI를 통해 조작할 수 있습니다. CR을 만들기 위해서는 CRD 혹은 Aggregated API 방법을 사용할 수 있습니다.

## 조정 루프
k8s의 핵심 컨셉중 하나는 `reconciliation loop (조정 루프)`입니다. (ProObject와 같은) 많은 APP에서는 어떤 서비스가 호출되면 특정 쓰레드에 해당 서비스의 핸들러를 실행하게 됩니다. 하지만 해당 핸들러가 도중에 실패한다면 해당 서비스는 실패합니다. 하지만 조정 루프 방법은 조금 다릅니다. 모든 API는 실제로 서비스의 핸들러를 호출하지 않습니다. 대신 어딘가에 저장되어 있는 메타데이터만을 수정합니다. 따라서 API 호출은 반드시 성공하고 즉각적으로 이루어집니다. 반면 이 메타데이터의 변경을 감지하고 있는 서버가 있습니다. 해당 서버는 지속적으로 메타데이터와 클러스터의 상태를 모니터링합니다. 그리고 상태가 다른 경우 지속적으로 핸들러를 수행하며 메타데이터와 클러스터의 상태를 맞추려고 노력합니다. 조정 루프라고 불리는 이유가 바로 여기에 있습니다. 이 서버는 메타데이터와 클러스터 사이의 차이를 반복해서 모니터링(루프)하며 상태를 맞추기 위해(조정) 노력합니다. CR을 포함한 k8s의 모든 리소스는 이 조정 루프 방법을 사용합니다.

## Custom Resource Definition (CRD)
CRD는 CR을 yaml파일로 정의하면 해당하는 CR의 API 엔드포인트를 k8s가 직접 만들어주는 방법입니다. k8s는 엔드포인트만을 만들어주기 때문에 실제 k8s 클러스터에 어떤 내용을 반영하려면 별개로 서버가 필요합니다. CRD 자체는 etcd에 메타데이터를 추가하는 방법과 그 방법에 대한 REST API를 제공할 뿐 입니다. 일반적으로 조정 루프를 구현하는 Operator Pattern을 사용해 해당 메타데이터를 클러스터에 반영하게 됩니다.

## Aggregated API (AA)
AA는 사용자에게 새로운 API 서버를 k8s에 추가할 수 있게 합니다. CRD와의 가장 큰 차이점이 여기에 있습니다. CRD는 `kind: CRD`를 정의하면 해당하는 API를 k8s api-server에 자동으로 만들어줍니다. 하지만 AA에서는 API 서버 자체를 별도로 구현해야 합니다. 이후 해당 API 서버의 REST API를 k8s에 등록해서 k8s가 해당 API 서버를 직접 호출할 수 있게 합니다. 즉 AA는 API gateway의 역할을 수행합니다. 이 방법은 API 서버 자체를 직접 구현하기 때문에 CRD보다 유연합니다. 예를 들어 CRD의 모든 데이터는 k8s의 etcd에만 저장되지만 AA에서는 DB를 목적에 맞게 (보안이 강화된 DB 혹은 타임시리즈 DB 등)에 저장할 수 있습니다. 또한 CRD에서는 기본적으로 생성되는 CRUD에 대해서만 API가 추가되지만 AA에서는 CRUD가 아닌 API(예를 들어 kubectl logs, kubectl exec)의 API도 추가할 수 있습니다. 하지만 API 서버의 유지보수를 직접 해야 하는 단점이 있습니다. 또한 직접 제작한 API 서버를 k8s에 등록하기 위해 인증인가 과정에 대한 지식이 필요합니다. 기존의 HyperCloud에서 PO를 계속해서 사용한다면 이 모델을 사용하는것이 좋습니다.


# CRD의 목적과 필요성
HCS는 별개의 기능을 자체 구현하고 있지는 않기 때문에 CRD의 목적은 여러 스토리지 app들의 orchestration입니다. 예를 들어 rook의 경우 CRD를 먼저 배포하고 Operator를 배포한 뒤 CR을 만들고 toolbox를 생성해야 합니다. 원래는 이런 순서관계 없이 한꺼번에 배포하면 조정루프를 통해 정상 상태가 되는 것이 맞지만, 실제로 순서가 존재하는것이 사실입니다. HCS CRD에서는 이런 순서를 모두 거치고 정상적으로 배포가 되면 spec.State가 OK로 표시됩니다.

## 장점
- 순서관계가 있는 yaml을 순서대로 배포할 수 있습니다.
- 모든 상태를 종합해서 hcs.spec.state에 표시할 수 있습니다.

## 단점
- 추가적인 go 프로그래밍이 필요합니다.
- 잘못 구현하면 오히려 버그가 늘어나거나 유지보수 비용이 증가할 수 있습니다.


# CRD 도입시 시나리오
1. 사용자는 먼저 HCS CRD를 배포합니다.
2. 사용자는 HCS CR을 정의한 yaml을 배포합니다. `kubectl create -f hcs.yaml` 이 yaml은 `Helm 차트` 혹은 `Kustomize`에 의해 배포될 수 있습니다.
3. HCS Operator는 조정 루프를 통해 클러스터와 메타데이터의 차이를 비교합니다. 여기서는 새로운 HCS CR이 생성되었으므로 Rook 설치, CDI 설치등을 순서대로 진행합니다.
4. `kubectl get hypercloudstorage`를 했을 때 state에 OK, ERROR 등이 표시됩니다.


# HCS CR 필드 구성
```
spec:
  storage:
    replicas: 3
    nodes:
      hostname: a
      devices:
      - /dev/sda
  cdi:
    ...
```
